#T100 #边缘计算 #消息队列 #OPS #DEV 
# MQTT 协议介绍
## 描述

MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于`发布/订阅`（`publish/subscribe`）模式的“轻量级”通讯协议，该协议构建于TCP/IP协议上，由IBM在1999年发布。
MQTT最大优点在于，**用极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务**。
作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 ^2f7a7b

## MQTT协议特点

MQTT是一个基于**客户端-服务器**的消息发布/订阅传输协议。
MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。在很多情况下，包括受限的环境中，如：机器与机器（M2M）通信和物联网（IoT）。
其在，通过卫星链路通信传感器、偶尔拨号的医疗设备、智能家居、及一些小型化设备中已广泛使用。
MQTT协议当前版本为，2014年发布的MQTT v3.1.1。除标准版外，还有一个简化版`MQTT-SN`，该协议主要针对嵌入式设备，这些设备一般工作于TCP/IP网络，如：ZigBee。
MQTT 与 HTTP 一样，MQTT 运行在传输控制协议/互联网协议 (TCP/IP) 堆栈之上。

![[Pasted image 20221107103948.png]]
### 发布和订阅

`MQTT`使用的发布/订阅消息模式，它提供了一对多的消息分发机制，从而实现与应用程序的解耦。

这是一种消息传递模式，**消息不是直接从发送器发送到接收器**（即点对点），而是由`MQTT server`（或称为 MQTT Broker）分发的。

![[Pasted image 20221107104106.png]]

**MQTT 服务器是发布-订阅架构的核心**。
它可以非常简单地在Raspberry Pi或NAS等单板计算机上实现，当然也可以在大型机或 Internet 服务器上实现。
服务器分发消息，因此必须是发布者，但绝不是订阅者！
客户端可以发布消息（发送方）、订阅消息（接收方）或两者兼而有之。
客户端（也称为节点）是一种智能设备，如微控制器或具有 TCP/IP 堆栈和实现 MQTT 协议的软件的计算机。
消息在允许过滤的主题下发布。主题是分层划分的 UTF-8 字符串。不同的主题级别用斜杠`/`作为分隔符号。
我们来看看下面的设置。

-   光伏发电站是发布者（`Publisher`）。
-   主要主题（`Topic`）级别是`"PV"`，这个工厂发布两个子级别`"sunshine"`和`"data"`；
-   `"PV/sunshine"`是一个布尔值（true/fault，也可以是 1/0），充电站需要它来知道是否应该装载电动汽车（仅在阳光普照时 :)）。
-   充电站（EVSE）是订阅者，订阅`"PV/sunshine"`从服务器获取信息。
-   `"PV/data"` 另一方面，以 kW 为单位传输工厂产生的瞬时功率，并且该主题可以例如通过计算机或平板电脑订阅，以生成一天内传输功率的图表。

这就是一个简单的MQTT的应用场景，具体如下图所示；

![[Pasted image 20221107104404.png]]

### QoS（Quality of Service levels）

服务质量是 MQTT 的一个重要特性。当我们使用 TCP/IP 时，连接已经在一定程度上受到保护。但是在无线网络中，中断和干扰很频繁，MQTT 在这里帮助避免信息丢失及其服务质量水平。这些级别在发布时使用。如果客户端发布到 MQTT 服务器，则客户端将是发送者，MQTT 服务器将是接收者。当MQTT服务器向客户端发布消息时，服务器是发送者，客户端是接收者。

**QoS 0**
这一级别会发生消息丢失或重复，消息发布依赖于底层TCP/IP网络。即：<=1

![[Pasted image 20221107104504.png]]

**QoS 1**
QoS 1 承诺消息将至少传送一次给订阅者。

**QoS 2**
使用 QoS 2，我们保证消息仅传送到目的地一次。为此，带有唯一消息 ID 的消息会存储两次，首先来自发送者，然后是接收者。QoS 级别 2 在网络中具有最高的开销，因为在发送方和接收方之间需要两个流。
![[Pasted image 20221107104618.png]]

## MQTT 数据包结构

-   `固定头（Fixed header）`，存在于所有`MQTT`数据包中，表示数据包类型及数据包的分组类标识；
-   `可变头（Variable header）`，存在于部分`MQTT`数据包中，数据包类型决定了可变头是否存在及其具体内容；
-   `消息体（Payload）`，存在于部分`MQTT`数据包中，表示客户端收到的具体内容；

整体MQTT的消息格式如下图所示；

![[Pasted image 20221107104720.png]]

### `MQTT` 固定头
`固定头`存在于所有`MQTT`数据包中，其结构如下：

![[Pasted image 20221107104820.png]]
下面简单分析一下固定头的消息格式；
#### `MQTT`消息类型 / message type
**位置** byte 1, bits 7-4。
4位的无符号值，类型如下：

|**名称**|**值**|**流方向**|**描述**|
|:---|:---|:---|:---|

#### 标识位 / DUP
**位置** byte 1, bits 3-0。
在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：

|**数据包**|**标识位**|**Bit 3**|**Bit 2**|**Bit 1**|**Bit 0**|
|:---|:---|:---|:---|:---|:---|

-   `DUP`：发布消息的副本。用来在保证消息的可靠传输，如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。
-   `QoS`： 发布消息的服务质量（前面已经做过介绍），即：保证消息传递的次数
	-   `00`：最多一次，即：<=1
	-   `01`：至少一次，即：>=1
	-   `10`：一次，即：=1
	-   `11`：预留
-   `RETAIN`：发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。

#### 剩余长度（Remaining Length）

**位置**：byte 1。

固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为 1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0

### `MQTT`可变头 / Variable header

`MQTT`数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是做为包的标识：

|**Bit**|**7 - 0**|
|:---|:---|

很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：
PUBLISH (QoS > 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、
SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK

### 消息体 / Payload

`Payload`消息体是`MQTT`数据包的第三部分，CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息 有消息体：
-   `CONNECT`，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码
-   `SUBSCRIBE`，消息体内容是一系列的要订阅的主题以及`QoS`。
-   `SUBACK`，消息体内容是服务器对于`SUBSCRIBE`所申请的主题及`QoS`进行确认和回复。
-   `UNSUBSCRIBE`，消息体内容是要订阅的主题。

## 知识和技能点

### MQTT 服务安装部署

[[MQTT 服务安装部署]]

### MQTT 客户端

[[Go语言订阅和发布MQTT协议数据流]]
[[Python语言订阅和发布MQTT协议数据流]]
[[Java 语言订阅和发布 MQTT 协议数据流]]
[[C 语言订阅和发布 MQTT 协议数据流]]



